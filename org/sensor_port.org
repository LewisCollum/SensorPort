#+property: header-args :dir ../source/ :cache yes :noweb yes :exports code :eval no :results output
#+options: toc:nil num:nil

#+title: Sensor Port 
#+author: Lewis Collum

*** Tasks [3/6]
**** DONE Nodes need to handle multiple inputs                       :T712_1:
	 CLOSED: [2019-07-21 Sun 00:13]
**** DONE Nodes with feedback capabilities                           :T712_2:
	 CLOSED: [2019-07-21 Sun 00:13] Joiners allow feedback
**** TODO Kalman Expectation Maximization algorithm for covariance matrices :T715_1:
**** TODO Extract input type from TerminalDistributor then make a Factory for deciding input type :T719_1:terminal:
**** DONE Extract ~package.setdefault("strategies", []).append(self.strategy.__class__.__name__~ from =node= :T720_1:node:
	 CLOSED: [2019-07-24 Wed 17:54]
**** TODO Buffering strategy for Joiners                      :T724_1:Joiner:
	 - ~self.joinables = dict.fromkeys(self.joinables)~ clears the "buffer".
* Modules
** base
*** receiver                                                         :mocked:
**** source
 #+BEGIN_SRC python :tangle ../source/receiver.py
import abc

class Receiver:
    @abc.abstractmethod
    def onReceivedPackage(self, package): pass
 #+END_SRC
**** mock
 #+BEGIN_SRC python :tangle ../source/mock_receiver.py
from receiver import Receiver

class MockReceiver(Receiver):
    def __init__(self): self.package = None
    def onReceivedPackage(self, package): self.package = package
 #+END_SRC
*** handler
**** source
#+BEGIN_SRC python :tangle ../source/handler.py
import abc

class Handler(abc.ABC):
    @abc.abstractmethod
    def handle(self, package): pass
#+END_SRC
*** connector
**** source
 #+BEGIN_SRC python :tangle ../source/connector.py
import abc
from receiver import Receiver

class Connector:
    @abc.abstractmethod
    def connect(self, receiver: Receiver): pass

    @abc.abstractmethod
    def disconnect(self): pass

    
class NamingConnector:
    @abc.abstractmethod
    def connect(self, name: str, receiver: Receiver): pass
    
    @abc.abstractmethod
    def disconnect(self, name: str): pass
 #+END_SRC
*** distributor                                               :tested:mocked:
**** source
 #+BEGIN_SRC python :tangle ../source/distributor.py
import abc
from connector import Connector
from connector import NamingConnector
from receiver import Receiver
import package as pk

class Distributor:
    @abc.abstractmethod
    def distribute(self, package): pass

            
class SingleDistributor(Distributor, Connector):
    def distribute(self, package):
        self.receiver.onReceivedPackage(package)

    def connect(self, receiver: Receiver):
        self.receiver = receiver
        
    def disconnect(self):
        self.receiver = None
        
    
class MultiDistributor(Distributor, Connector):
    def __init__(self):
        self.receivers = []

    def distribute(self, package):
        for receiver in self.receivers:
            receiver.onReceivedPackage(package)
        
    def connect(self, receiver: Receiver):
        self.receivers.append(receiver)

    def disconnect(self):
        self.receivers.clear()

        
class NamingDistributor(Distributor, NamingConnector):
    def __init__(self):
        self.receivers = {}

    def distribute(self, package):
        for receiver in self.receivers[pk.PackageConfig.nameFromDict(package)]:
            receiver.onReceivedPackage(package)
        
    def connect(self, name: str, receiver: Receiver):
        self.receivers.setdefault(name, []).append(receiver)
        
    def disconnect(self):
        self.receivers.clear()
 #+END_SRC
**** test
 #+BEGIN_SRC python :tangle ../source/test_distributor.py
import unittest
import distributor as d
import mock_receiver as mh
import package as pk

class TestSingleDistributor(unittest.TestCase):
    def setUp(self):
        self.receiver = mh.MockReceiver()
        self.distributor = d.SingleDistributor()
        self.distributor.connect(self.receiver)
        
    def test_distributeToSingleReceiver(self):
        expected = "abc"
        self.distributor.distribute(expected)
        actual = self.receiver.package

        self.assertEqual(actual, expected)
        

class TestMultiDistributor(unittest.TestCase):
    def setUp(self):
        self.receiverA = mh.MockReceiver()
        self.receiverB = mh.MockReceiver()
        self.distributor = d.MultiDistributor()
        self.distributor.connect(self.receiverA)
        self.distributor.connect(self.receiverB)
        
    def test_distributeToReceiverA(self):
        expected = "abc"
        self.distributor.distribute(expected)
        actualA = self.receiverA.package
        
        self.assertEqual(actualA, expected)

    def test_distributeToReceiverB(self):
        expected = "abc"
        self.distributor.distribute(expected)
        actualB = self.receiverB.package
        
        self.assertEqual(actualB, expected)


class TestNamingDistributor(unittest.TestCase):
    def setUp(self):
        self.distributor = d.NamingDistributor()
        self.receiver = mh.MockReceiver()

        self.distributor.connect("A", self.receiver)
        
    def test_distributeToReceiverA(self):
        expectedPackage = pk.Package.make(name = "A")
        self.distributor.distribute(expectedPackage)

        actualPackage = self.receiver.package
        
        self.assertEqual(actualPackage, expectedPackage)
        
        
if __name__ == '__main__':
    unittest.main()
 #+END_SRC
**** mock
 #+BEGIN_SRC python :tangle ../source/mock_distributor.py
from receiver import Receiver
from distributor import Distributor
from distributor import NamingDistributor

class MockDistributor(Distributor):
    def distribute(self, package):
        self.receiver.onReceivedPackage(package)

    def connect(self, receiver: Receiver):
        self.receiver = receiver

    def disconnect(self): pass


class MockNamingDistributor(NamingDistributor):
    def __init__(self):
        self.receiver = {}
    
    def distribute(self, package):
        self.receiver[package.name].onReceivedPackage(package)
        
    def connect(self, name: str, receiver: Receiver):
        self.receiver[name] = receiver
        
    def disconnect(self): pass
 #+END_SRC
*** node
**** source
#+BEGIN_SRC python :tangle ../source/node.py
from receiver import Receiver
from handler import Handler
from distributor import Distributor

class Node(Receiver):
    def __init__(self, handler: Handler, distributor: Distributor):
        self.handler = Handler
        self.distributor = Distributor

    def onReceivedPackage(self, package):
        self.distributor.distribute(self.handler.handle(package))        
#+END_SRC
*** joining_node                                              :tested:mocked:
**** source
 #+BEGIN_SRC python :tangle ../source/joining_node.py
import abc
import distributor as d
from connector import Connector
from receiver import Receiver
import package as pk

class JoiningNode(Receiver):
    def __init__(self, *joinableNames):
        self.joinables = dict.fromkeys(joinableNames)
        self.distributor = d.SingleDistributor()

    @abc.abstractmethod
    def join(self, joinables: dict): pass
        
    def onReceivedPackage(self, package):
        self.setJoinablePackage(package)
        if self.hasPackageForEachJoinable():
            joinedPackage = self.join(self.joinables)
            self.distributor.distribute(joinedPackage)        
            self.clearJoinablePackages()

    def setJoinablePackage(self, package):
        self.joinables[pk.PackageConfig.nameFromDict(package)] = package
            
    def hasPackageForEachJoinable(self):
        return None not in self.joinables.values()        
        
    def clearJoinablePackages(self):
        self.joinables = dict.fromkeys(self.joinables)

    def connect(self, receiver):
        self.distributor.connect(receiver)

    def disconnect(self):
        self.distributor.disconnect()
 #+END_SRC
**** test
 #+BEGIN_SRC python :tangle ../source/test_joiner.py
import unittest
import mock_joiner as mj
import mock_distributor as md
import mock_receiver as mr
import package as pk

class TestJoiningNode(unittest.TestCase):
    def setUp(self):
        self.distributorA = md.MockDistributor()
        self.distributorB = md.MockDistributor()
        self.adder = mj.MockAddJoiningNode("A", "B")
        self.packageReceiver = mr.MockReceiver()

        self.distributorA.connect(self.adder)
        self.distributorB.connect(self.adder)
        self.adder.connect(self.packageReceiver)

    def test_receiverReceivesFusedJoiningNodeOutput(self):
        packageA = pk.Package.make(name = "A", value = 1)
        packageB = pk.Package.make(name = "B", value = 2)
        expectedSum = packageA.value + packageB.value
        self.distributorA.distribute(packageA)
        self.distributorB.distribute(packageB)

        self.assertEqual(self.packageReceiver.package.value, expectedSum)

if __name__ == '__main__':
    unittest.main()
 #+END_SRC
**** mock
 #+BEGIN_SRC python :tangle ../source/mock_joiner.py
from joining_node import JoiningNode
import distributor
import package as pk

class MockAddJoiningNode(JoiningNode):
    def join(self, joinables): return pk.Package.make(name = None, value = sum(package.value for package in joinables.values()))
 #+END_SRC
*** json_handler                                                     :tested:
**** source
 #+BEGIN_SRC python :tangle ../source/json_handler.py
from receiver import Receiver
from connector import Connector
from handler import Handler
import json

class JsonLoadHandler(Handler):
    def handle(self, package):
        return json.loads(package)

class JsonDumpHandler(Handler):
    def __init__(self, jsonEncoder = None):
        self.jsonEncoder = jsonEncoder

    def handle(self, package):
        return json.dumps(package, cls = self.jsonEncoder)
 #+END_SRC
**** test
#+BEGIN_SRC python :tangle ../source/test_json_handler.py
import unittest
from json_handler import JsonLoadHandler, JsonDumpHandler
import mock_distributor as md
import mock_receiver as mr

class TestJsonLoadHandler(unittest.TestCase):
    def setUp(self):
        self.jsonLoadHandler = JsonLoadHandler()
        
    def test_load(self):
        expected = {"A": 0}
        actual = self.jsonLoadHandler.handle('{"A": 0}')
        
        self.assertEqual(actual, expected)
        
class TestJsonDumpHandler(unittest.TestCase):
    def setUp(self):
        self.jsonDumpHandler = JsonDumpHandler()
        
    def test_load(self):
        expected = '{"A": 0}'
        actual = self.jsonDumpHandler.handle({"A": 0})

        self.assertEqual(actual, expected)
#+END_SRC
** peripheral
*** terminal
**** source
 #+BEGIN_SRC python :tangle ../source/terminal.py
import sys
from connector import Connector
from distributor import Distributor
from receiver import Receiver

class Terminal:
    def __init__(self, distributor: Distributor):
        self.distributor = distributor
        self.terminalInput = open(sys.argv[1]) if len(sys.argv) > 1 else sys.stdin

    def startDistributing(self):
        for line in self.terminalInput:
            self.distributor.distribute(line)

            
class TerminalDistributor(Distributor, Connector):
    def __init__(self):
        self.terminalInput = open(sys.argv[1]) if len(sys.argv) > 1 else sys.stdin

    def startDistributing(self):
        for line in self.terminalInput:
            self.distribute(line)
        
    def distribute(self, package):
        self.receiver.onReceivedPackage(package)
        
    def connect(self, receiver: Receiver):
        self.receiver = receiver

    def disconnect(self):
        self.receiver = None


class FileWriter(Receiver):
    def __init__(self, fileName: str):
        self.fileName = fileName
        self.output = open(self.fileName, "w+")
    
    def onReceivedPackage(self, package: str):
        self.output.write(package)
        if not package.endswith('\n'):
            self.output.write('\n')

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.output.close()
        

class StdoutWriter(Receiver):
    def onReceivedPackage(self, package: str):
        print(package)
 #+END_SRC
** package
*** package
**** source
 #+BEGIN_SRC python :tangle ../source/package.py
import abc 

class PackageConfig:
    name = "name"
    value = "value"
    timestamp = "timestamp"

    @classmethod
    def nameFromDict(cls, d):
        return d.get(cls.name)

    @classmethod
    def valueFromDict(cls, d):
        return d.get(cls.value)

    @classmethod
    def timestampFromDict(cls, d):
        return d.get(cls.timestamp)
    
class Package:
    def __init__(self, package: dict):
        self.package = package

    def get(self, key):
        return self.package.get(key)

    @property
    def name(self):
        return self.package[PackageConfig.name]
        
    @property
    def value(self):
        return self.package[PackageConfig.value]
    
    @value.setter
    def value(self, value):
        self.package[PackageConfig.value] = value

    @property
    def timestamp(self):
        return self.package[PackageConfig.timestamp]
    
    @classmethod
    def make(cls, name: str = None, value = None, timestamp: int = None):
        return cls({PackageConfig.name: name, PackageConfig.value: value, PackageConfig.timestamp: timestamp})

    @classmethod
    def nameFromPackage(cls, package):
        return package.name
    
    @classmethod
    def valueFromPackage(cls, package):
        return package.value

    @classmethod
    def timestampFromPackage(cls, package):
        return package.timestamp
    
    
class PackageValue(abc.ABC):
    containerClass = tuple
    
    def __init__(self, values):
        self.values = values

    def __eq__(self, other):
        return self.values == other.values
        
    @classmethod
    def fromContainer(cls, values):
        if values == None:
            return None
        elif values.__class__ == PackageValue.containerClass:
            return cls(values) 
        return cls(cls.containerClass(values))
 #+END_SRC
*** packaging_handler
**** source
#+BEGIN_SRC python :tangle ../source/packaging_handler.py
import package as pk
from handler import Handler

class PackagingHandler(Handler):
    def __init__(self, PackageValueClass: pk.PackageValue = pk.PackageValue):
        self.PackageValueClass = PackageValueClass

    def handle(self, package: dict):
        values = pk.PackageConfig.valueFromDict(package)
        return pk.Package.make(
            name = pk.PackageConfig.nameFromDict(package),
            value = self.PackageValueClass.fromContainer(values),
            timestamp = pk.PackageConfig.timestampFromDict(package))
#+END_SRC
**** test
#+BEGIN_SRC python :tangle ../source/test_packaging_handler.py
import unittest
from packaging_handler import PackagingHandler
import package as pk

class TestPackagingHandler(unittest.TestCase):
    def setUp(self):
        self.packagingHandler = PackagingHandler()

    def test_dictToPackage_namesEqual(self):
        expected = pk.Package.make(name = "A")
        actual = self.packagingHandler.handle({"name": "A"})

        self.assertEqual(actual.name, expected.name)

    def test_dictToPackage_valuesEqual(self):
        expected = pk.Package.make(value = pk.PackageValue.fromContainer((1, 2)))
        actual = self.packagingHandler.handle({"value": (1,2)})

        self.assertEqual(actual.value, expected.value)
#+END_SRC
*** encoder
  #+BEGIN_SRC python :tangle ../source/encoder.py
import json
import numpy
import package as pk

class NumpyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, numpy.ndarray):
            return obj.tolist()
        return json.JSONEncoder.default(self, obj)

class PackageEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, pk.Package):
            return obj.package
        elif isinstance(obj, pk.PackageValue):
            return obj.values
  #+END_SRC
** imu
*** imu
**** source
 #+BEGIN_SRC python :tangle ../source/imu.py
from joining_node import JoiningNode
import distributor as d
import quaternion as quat
import package as pk
import package_imu as pk_imu

class QuaternionVectorJoiningNode(JoiningNode):
    def join(self, joinables):
        quaternionPackage = joinables[self.quaternionName]
        vectorPackage = joinables[self.vectorName]

        quaternion = quat.Quaternion(
	    quaternionPackage.value[0:3],
            quaternionPackage.value[3])

        vector = quaternion.rotateVector(vectorPackage.value)

        name = self.__class__.__name__
        value = pk_imu.Vector3D.fromContainer(vector)
        timestamp = int((quaternionPackage.timestamp + vectorPackage.timestamp)/2)

        return pk.Package.make(name, value, timestamp)

    @classmethod
    def makeFromNames(cls, quaternionName: str, vectorName: str):
        made = cls(quaternionName, vectorName)
        made.quaternionName = quaternionName
        made.vectorName = vectorName
        return made
 #+END_SRC
**** test
 #+BEGIN_SRC python :tangle ../source/test_imu.py
import unittest
import imu
import mock_distributor as md
import mock_receiver as mr
import package_imu as pk_imu
import package as pk

class TestQuaternionVectorJoiningNode(unittest.TestCase):
    def setUp(self):
        self.vectorDistributor = md.MockDistributor()
        self.quaternionDistributor = md.MockDistributor()
        self.joiner = imu.QuaternionVectorJoiningNode.makeFromNames(
            quaternionName = "Quaternion",
            vectorName = "Vector")
        self.receiver = mr.MockReceiver()

        self.quaternionDistributor.connect(self.joiner)
        self.vectorDistributor.connect(self.joiner)
        self.joiner.connect(self.receiver)
        
    def test_receivedRotatedVector(self):
        vectorPackage = pk.Package.make(
            name="Vector",
            value=pk_imu.Vector3D.fromComponents(x=1,y=0,z=0).toTuple(),
            timestamp=1)
        quaternionPackage = pk.Package.make(
            name="Quaternion",
            value=pk_imu.Quaternion.fromComponents(x=0,y=0,z=1,scalar=0).toTuple(),
            timestamp=3)
        self.vectorDistributor.distribute(vectorPackage)
        self.quaternionDistributor.distribute(quaternionPackage)

        expected = pk_imu.Vector3D.fromComponents(x=-1,y=0,z=0).values
        actual = self.receiver.package.value.values
        self.assertEqual(expected, actual)

if __name__ == '__main__':
    unittest.main()        
 #+END_SRC
*** integrator
**** source
#+BEGIN_SRC python :tangle ../source/integrator.py
import pair
import package as pk
from handler import Handler

class Integrator(Handler):
    def __init__(self, name: str = None):
        self.name = name
        self.time = pair.Pair()
        self.value = pair.Pair()
        
    def handle(self, package):
        self.time.shift(package.timestamp)
        self.value.shift(package.value)
        if self.time.previous != None:
            value = self.value.previous + self.value.current*self.time.difference
            return pk.Package.make(self.name, value, self.time.current) 
#+END_SRC
**** test
#+BEGIN_SRC python :tangle ../source/test_integrator.py
import unittest
from integrator import Integrator
import mock_distributor as md
import mock_receiver as mr
import package as pk
import numpy

class TestIntegrator(unittest.TestCase):
    def setUp(self):
        self.integrator = Integrator()
        
    def test_integrated(self):
        packageA = pk.Package.make(value = numpy.array((1, 2, 3)), timestamp = 0)
        packageB = pk.Package.make(value = numpy.array((1, 2, 3)), timestamp = 2)
        self.integrator.handle(packageA)
        
        expected = (3, 6, 9)
        actual = tuple(self.integrator.handle(packageB).value)

        self.assertEqual(actual, expected)
#+END_SRC
*** package_imu
**** source
 #+BEGIN_SRC python :tangle ../source/package_imu.py
import package as pk

class Vector3D(pk.PackageValue):
    @property
    def x(self):
        return self.values[0]
    
    @property
    def y(self):
        return self.values[1]
    
    @property
    def z(self):
        return self.values[2]
            
    @classmethod
    def fromComponents(cls, x, y, z):
        return cls.fromContainer(values = (x, y, z))

    def toTuple(self):
        return (self.x, self.y, self.z)
        
    
class Quaternion(pk.PackageValue):
    @property
    def vector(self):
        return self.values[0:3]

    @property
    def x(self):
        return self.values[0]
    
    @property
    def y(self):
        return self.values[1]
    
    @property
    def z(self):
        return self.values[2]

    @property
    def scalar(self):
        return self.values[3]
        
    @classmethod
    def fromComponents(cls, x, y, z, scalar):
        return cls.fromContainer(values = (x, y, z, scalar))

    def toTuple(self):
        return (self.x, self.y, self.z, self.scalar)
 #+END_SRC
**** test
 #+BEGIN_SRC python :tangle ../source/test_package_imu.py
import package as pk
import package_imu as pk_imu
import unittest

class TestVector3D(unittest.TestCase):
    def setUp(self):
        self.expected = (1, 2, 3)
        
    def test_fromContainer_vectorMatches(self):
        vector = pk_imu.Vector3D.fromContainer(self.expected)

        self.assertEqual(self.expected, vector.values)

    def test_fromComponents_vectorMatches(self):
        x, y, z = self.expected
        vector = pk_imu.Vector3D.fromComponents(x, y, z)

        self.assertEqual(self.expected, vector.values)


class TestQuaternion(unittest.TestCase):
    def setUp(self):
        self.expected = (1, 2, 3, 0)

    def test_fromContainer_valuesMatch(self):
        quaternion = pk_imu.Quaternion.fromContainer(self.expected)

        self.assertEqual(self.expected, quaternion.values)
        
    def test_fromComponents_valuesMatch(self):
        x, y, z, scalar = self.expected
        quaternion = pk_imu.Quaternion.fromComponents(x, y, z, scalar)

        self.assertEqual(self.expected, quaternion.values)

if __name__ == '__main__':
    unittest.main()
 #+END_SRC
*** pair
 #+BEGIN_SRC python :tangle ../source/pair.py
class Pair:
    def __init__(self, initial = None):
        self.pair = [None, initial]
        
    def shift(self, new = None):
        self.pair[0] = self.pair[1]
        self.pair[1] = new

    def offsetFromPrevious(self, offset):
        self.pair[1] = self.pair[0] + offset
                
    @property
    def current(self):
        return self.pair[1]

    @property
    def previous(self):
        return self.pair[0]

    @property
    def difference(self):
        return self.pair[1] - self.pair[0]
 #+END_SRC
*** quaternion
**** source
 #+BEGIN_SRC python :tangle ../source/quaternion.py    
import copy

class Quaternion:
    normalizingStrategy = None
    
    def __init__(self, vector, scalar):        
        self.vector = vector
        self.scalar = scalar
        
    def rotateVector(self, vector):
        quaternionFromVector = Quaternion(vector=vector, scalar=0)
        resultantQuaternion = self * quaternionFromVector * self.conjugate()
        return resultantQuaternion.vector
        
    def conjugate(self):
        conjugatedVector = self.vector.__class__((-i for i in self.vector))
        return Quaternion(vector=conjugatedVector, scalar=self.scalar)
        
    def __mul__(self, other):
        b1, c1, d1 = self.vector
        a1 = self.scalar
        b2, c2, d2 = other.vector
        a2 = other.scalar

        w = a1*a2 - b1*b2 - c1*c2 - d1*d2
        x = a1*b2 + b1*a2 + c1*d2 - d1*c2
        y = a1*c2 - b1*d2 + c1*a2 + d1*b2
        z = a1*d2 + b1*c2 - c1*b2 + d1*a2
        return Quaternion(vector=self.vector.__class__([x, y, z]), scalar=w)
    
    def normalize(self):
        Quaternion.normalizingStrategy(self)
 #+END_SRC
**** documentation
	Two quaternions, that represent two distinct rotations, can be
	multiplied together to get a single, resultant, rotation
	(https://en.wikipedia.org/wiki/Quaternion#Hamilton_product). This
	property allows a quaternion to be applied to a vector
	(e.g. acceleration) by "conjugating" the quaternion by the vector
	([[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Using_quaternion_as_rotations]]).

	In the class ~Quaternion~, the multiplication operator, ~__mul__~,
	is overloaded to represent Hamiltonian multiplication.
   
	Quaternions can be applied to vectors, via "conjugation", using
	~applyToVector~.
**** test
 #+BEGIN_SRC python :tangle ../source/test_quaternion.py
import unittest
import quaternion

class TestQuaternion(unittest.TestCase):

    def test_rotateListVector(self):
        self.quaternion = quaternion.Quaternion((0, 0, 0), 1)        

if __name__ == '__main__':
    unittest.main()
 #+END_SRC
** kalman
*** kalman_node
#+BEGIN_SRC python :tangle ../source/kalman_node.py
from handling_node import HandlingNode
import numpy
import pair

class KalmanNode(HandlingNode):
    def __init__(self):
        #seconds = pair.TimePair(initial = initial["millis"]/1000)
        ms = 5
        dt = numpy.eye(9)*ms
        self.stateModel = 
        self.stateVariance = None
        self.measurementModel = None
        self.measurementVariance = None
    
        self.state = None
        self.processVariance = None

    def setStateModel(model: numpy.ndarray):
        self.stateModel = model

    def setMeasurementModel(model: numpy.ndarray):
        self.measurementModel = model
        
    def handle(self, package):
        measurement = package.value.values
        
        self.state = self.stateModel.dot(self.state)
        self.processVariance = self.stateModel.dot(self.processVariance).dot(self.stateModel.T) + self.stateVariance
        s = measurementModel.dot(processVariance).dot(measurementModel.T) + measurementVariance
        gain = processVariance.dot(measurementModel.T).dot(numpy.linalg.inv(s))
        self.state = self.state + gain.dot(measurement - measurementModel.dot(state))
        self.processVariance = self.processVariance - gain.dot(self.measurementModel).dot(self.processVariance)



            
state = numpy.zeros(State.size)
stateModel = numpy.eye(9)
measurement = numpy.zeros(State.dimensions)
measurementModel = numpy.hstack((numpy.zeros((State.dimensions, State.size-State.dimensions)), numpy.eye(State.dimensions)))
stateVariance = 0 #numpy.eye(State.size)*0.0005
measurementVariance = numpy.eye(State.dimensions)*0.0005
processVariance = numpy.eye(State.size)

first = numpy.eye(State.dimensions)*seconds.difference
second = numpy.eye(State.dimensions)*seconds.difference**2/2
stateModel[0:3,3:6] = first
stateModel[0:3,6:9] = second
stateModel[3:6,6:9] = first

state = stateModel.dot(state)
processVariance = stateModel.dot(processVariance).dot(stateModel.T) + stateVariance
s = measurementModel.dot(processVariance).dot(measurementModel.T) + measurementVariance
gain = processVariance.dot(measurementModel.T).dot(numpy.linalg.inv(s))
#gain = numpy.hstack((numpy.zeros((State.dimensions, State.size-State.dimensions)), numpy.eye(State.dimensions))).T

state = state + gain.dot(measurement - measurementModel.dot(state))
processVariance = processVariance - gain.dot(measurementModel).dot(processVariance)
#+END_SRC

** misc
*** strategy
**** source
 #+BEGIN_SRC python :tangle ../source/strategy.py
import pair 
import abc

class Strategy(abc.ABC):
    @abc.abstractmethod
    def execute(self, input): pass
            
class VarianceStrategy(Strategy):
    def __init__(self, initial):
        self.mean = pair.Pair(initial = initial)
        self.variance = initial
        self.count = 0

    def execute(self, input):
        self.mean.shift()
        self.count += 1
        deviation = input - self.mean.previous
        self.mean.offsetFromPrevious(deviation/self.count)
        deviationCurrent = input - self.mean.current
        self.variance += deviation*deviationCurrent
        return self.variance/self.count

 #+END_SRC
**** mock
 #+BEGIN_SRC python :tangle ../source/mock_strategy.py
import strategy

class MockStrategy(strategy.Strategy):
    def execute(self, input):
        return input
 #+END_SRC

*** COMMENT categorizer
 #+BEGIN_SRC python :tangle ../source/categorizer.py
class Categorizer:
    def __init__(self, keysToKeep: list):
        self.categorized = {}
        self.keys = keysToKeep
        
    def categorizeLine(self, line: dict):
        name = line["name"]
        if name not in self.categorized:
            self.categorized[name] = {}
            for key in self.keys:
                self.categorized[name][key] = []
                
        for key in self.keys:
            self.categorized[name][key].append(line[key])

    def items(self):
        return self.categorized.items()
 #+END_SRC

*** COMMENT receiver
 #+BEGIN_SRC python
class Receiver(observer.Observer):
    def __init__(self, name: str, subject, successor: Receiver):
        self.subject = subject
        self.successor = successor

    def onUpdateFromSubject(self, package):
        if package[self.name] == self.name:
            self.handle(package)
        else:
            self.forward(package)

    def handle(self, package):
        self.subject.notifySubscribers(package)

    def forward(self, package):
        if self.successor != None:
            self.successor.onUpdateFromSubject(package)
 #+END_SRC

*** COMMENT stream                                               :deprecated:
 #+BEGIN_SRC python :tangle ../source/stream.py :eval no-export
import asyncio
import ip

class StreamSubscriber:
    def update(self, packet: str):
        pass

    def shutdown(self):
        pass

class StreamPublisher:
    def __init__(self):
        self.subscribers = []
        
    def addSubscriber(self, subscriber: StreamSubscriber):
        self.subscribers.append(subscriber)

    def removeSubscriber(self, subscriber: StreamSubscriber):
        self.subscribers.remove(subscriber)

    def sendPacket(self):
        for subscriber in self.subscribers:
            subscriber.update(self.packet)

    def sendShutdown(self):
        for subscriber in self.subscribers:
            subscriber.shutdown()

    async def receiver(self, reader, writer):
        while not reader.at_eof():
            self.packet = (await reader.readline()).decode('utf-8')
            self.sendPacket()

        self.sendShutdown()

    async def start(self, port):
        self.server = await asyncio.start_server(self.receiver, ip.local(), port)
        async with self.server:
            await self.server.serve_forever()
 #+END_SRC
*** COMMENT ip                                                   :deprecated:
 #+BEGIN_SRC python :tangle ../source/ip.py
import subprocess

<<ip.local>>
 #+END_SRC

 #+name: ip.local
 #+BEGIN_SRC python
def local():
    command = 'ip addr | grep "global" | egrep -o "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | head -n1'
    process = subprocess.run(command, shell=True, check=True, encoding='utf-8', stdout=subprocess.PIPE)
    ip = process.stdout.split()
    if not ip: raise RuntimeError("No Network Connection")
    return ip[0]
 #+END_SRC

 #+BEGIN_SRC python :eval no-export
import ip
print(ip.local())
 #+END_SRC

 #+RESULTS[9ab9e9195a7e776c05bb1649a5967ef8e84217de]:
 : 192.168.0.101

*** COMMENT distributing_node
 #+BEGIN_SRC python :tangle ../source/distributing_node.py
import abc
from receiver import Receiver
from connector import Connector
from distributor import Distributor

class DistributionNode(Receiver):
    def __init__(self, distributor: Distributor):
        self.distributor = distributor

    def onReceivedPackage(self, package):
        self.distributor.distribute(package)
 #+END_SRC
*** COMMENT handling_node
 #+BEGIN_SRC python :tangle ../source/handling_node.py
import abc
from receiver import Receiver
from connector import Connector
from distributor import Distributor

class HandlingNode(Receiver):
    @abc.abstractmethod
    def handle(self, package): pass

    def setDistributor(self, distributor: Distributor):
        self.distributor = distributor
    
    def onReceivedPackage(self, package):
        self.distributor.distribute(self.handle(package))
 #+END_SRC

* Scripts
** applyKalman
#+BEGIN_SRC python :tangle ../script/run_applyKalman.py
<<include_source>>
import sys
import json
import numpy
import pykalman
import pair
import enum
import datetime
import fileinput
import os

class State:
    size = 9
    dimensions = 3
    
    class Position(enum.IntEnum):
        x, y, z = 0, 1, 2

    class Velocity(enum.IntEnum):
        x, y, z = 3, 4, 5

    class Acceleration(enum.IntEnum):
        x, y, z = 6, 7, 8
        

state = numpy.zeros(State.size)
stateModel = numpy.eye(9)
measurement = numpy.zeros(State.dimensions)
measurementModel = numpy.hstack((numpy.zeros((State.dimensions, State.size-State.dimensions)), numpy.eye(State.dimensions)))
stateVariance = numpy.eye(State.size)*0.00000005#0.00000005
measurementVariance = numpy.eye(State.dimensions)*0.0005#0.0005
processVariance = numpy.eye(State.size)

for sample in fileinput.input():
    if fileinput.isfirstline():
        initial = json.loads(sample)
        seconds = pair.Pair(initial = initial["millis"]/1000)
        acceleration = numpy.asarray(initial["values"])

        if fileinput.isstdin():
            output = sys.stdout
        else:
            output = open(f"{os.path.dirname(sys.argv[1])}/kalman.json", "w+")
    else:
        sensor = json.loads(sample)
        seconds.shift(sensor["millis"]/1000)

        measurement = numpy.asarray(sensor["values"])

        first = numpy.eye(State.dimensions)*seconds.difference
        second = numpy.eye(State.dimensions)*seconds.difference**2/2
        stateModel[0:3,3:6] = first
        #stateModel[0:3,6:9] = second
        stateModel[3:6,6:9] = first

        state = stateModel.dot(state)
        processVariance = stateModel.dot(processVariance).dot(stateModel.T) + stateVariance
        s = measurementModel.dot(processVariance).dot(measurementModel.T) + measurementVariance
        gain = processVariance.dot(measurementModel.T).dot(numpy.linalg.inv(s))
        #gain = numpy.hstack((numpy.zeros((State.dimensions, State.size-State.dimensions)), numpy.eye(State.dimensions))).T

        state = state + gain.dot(measurement - measurementModel.dot(state))
        processVariance = processVariance - gain.dot(measurementModel).dot(processVariance)
        
        # output.write(json.dumps({
        #     "name": "Meters",
        #     "millis": seconds.current,
        #     "values": [state[State.Position.x],state[State.Position.y]]}))#,state[State.Position.z]]}))
        # output.write('\n')
        
        # output.write(json.dumps({
        #     "name": "Meters/Seconds",
        #     "millis": seconds.current,
        #     "values": [state[State.Velocity.x],state[State.Velocity.y]]}))#,state[State.Velocity.z]]}))
        # output.write('\n')
        
        output.write(json.dumps({
            "name": "Meters/Second/Second",
            "millis": seconds.current*1000,
            "values": [state[State.Acceleration.x],state[State.Acceleration.y]]}))#,state[State.Acceleration.z]]}))
        output.write('\n')
        
output.close()









#+END_SRC
** imu
#+BEGIN_SRC python :tangle ../script/run_imu.py
<<include_source>>
import os

import imu
import package_imu as pk_imu
import distributor as d
import terminal as term
import package as pk
import packaging_handler as pn
import json_handler as jn
import encoder
        
pk.PackageConfig.timestamp = "millis"
pk.PackageConfig.value = "values"

accelerationName = "MPL Accelerometer"
rotationName = "Rotation Vector"

terminalDistributor = d.SingleDistributor()
terminal = term.Terminal(terminalDistributor)

loadDistributor = d.NamingDistributor()
loadHandler = jn.JsonLoadHandler()
loader = Node(

joiner = imu.QuaternionVectorJoiningNode.makeFromNames(
    quaternionName = rotationName,
    vectorName = accelerationName)

dumpDistributor = d.SingleDistributor()
dumper = jn.JsonDumpHandler(encoder.PackageEncoder)
dumper.setDistributor(dumpDistributor)

stdoutWriter = term.StdoutWriter()
fileWriter = term.FileWriter(f"{os.path.dirname(sys.argv[1])}/imu.json")

terminalDistributor.connect(loader)
loadDistributor.connect(accelerationName, joiner)
loadDistributor.connect(rotationName, joiner)
joiner.connect(dumper)
dumpDistributor.connect(stdoutWriter)
dumpDistributor.connect(fileWriter)
terminal.startDistributing()
#+END_SRC
** imu_2
#+BEGIN_SRC python 
terminal = term.TerminalInput(distributor = d.SingleDistributor())


#+END_SRC
** record
#+BEGIN_SRC python :tangle ../script/record.py
<<include_source>>
import terminal as term
from datetime import datetime
import os
import distributor as d

terminalDistributor = d.MultiDistributor()
terminal = term.Terminal(terminalDistributor)
stdoutWriter = term.StdoutWriter()
terminalDistributor.connect(stdoutWriter)

timeOfRecording = f"{datetime.now():%Y-%m-%d_%H:%M:%S}"
os.makedirs("output/" + timeOfRecording)

with term.FileWriter(f"output/{timeOfRecording}/raw.json") as fileWriter:
    terminalDistributor.connect(fileWriter)
    terminal.startDistributing()
#+END_SRC
** plot
#+BEGIN_SRC python :tangle ../script/plot.py
import matplotlib.pyplot as pyplot
import json
import sys
import re

class SensorPlotable:
    def __init__(self):
        self.values = []
        self.seconds = []

    def update(self, seconds: float, values: list):
        self.values.append(values)
        self.seconds.append(seconds)
        

class SensorPlotableManager:
    def __init__(self, title: str):
        self.sensors = {}
        self.title = title
        
    def update(self, name: str, seconds: float, values: list):
        if name not in self.sensors:
            self.sensors[name] = SensorPlotable()
        self.sensors[name].update(seconds, values)

    def plotAll(self):
        figure, axes = pyplot.subplots(nrows = len(self.sensors), squeeze = False, sharex = True)
        
        axes[0, 0].set_title(self.title)
        axes[len(self.sensors)-1, 0].set_xlabel("time (ms)")
        
        for i, (name, plotable) in enumerate(self.sensors.items()):
            axes[i, 0].set_ylabel(name)
            axes[i, 0].plot([i-plotable.seconds[0] for i in plotable.seconds], plotable.values)
                
        figure.tight_layout()
        pyplot.show()

        
manager = SensorPlotableManager(title = re.sub("^.*/", "", sys.argv[1]))
with open(sys.argv[1]) as jsonFile:
    for line in jsonFile:
        sample = json.loads(line)
        manager.update(sample["name"], sample["millis"], sample["values"])

manager.plotAll()
#+END_SRC
** split
#+BEGIN_SRC python :tangle ../script/split.py
<<include_source>>
import os
import terminal as term
import distributor as d
from handling_node import HandlingNode
import package as pk
import json_handler as jn

pk.PackageConfig.value = "values"
pk.PackageConfig.timestamp = "millis"

class RotationModifier(HandlingNode):
    def handle(self, package):
        package[pk.PackageConfig.name] = "Rotation (Quaternion)"
        package[pk.PackageConfig.value] = package[pk.PackageConfig.value][:4]
        return package

class AccelerationModifier(HandlingNode):
    def handle(self, package):
        package[pk.PackageConfig.name] = "Acceleration (m/s^2)"
        return package

    
fileName = os.path.splitext(os.path.basename(sys.argv[1]))[0]

accelerometerName = "MPL Accelerometer"
accelerometerPath = f"{os.path.dirname(sys.argv[1])}/{fileName}_accelerometer.json"

rotationName = "Rotation Vector"
rotationPath = f"{os.path.dirname(sys.argv[1])}/{fileName}_rotation.json"


terminalDistributor = d.MultiDistributor()
terminal = term.Terminal(terminalDistributor)

loadDistributor = d.NamingDistributor()
loader = jn.JsonLoadHandler()
loader.setDistributor(loadDistributor)

rotationDistributor = d.SingleDistributor()
rotationModifier = RotationModifier()
rotationModifier.setDistributor(rotationDistributor)
accelerometerDistributor = d.SingleDistributor()
accelerometerModifier = AccelerationModifier()
accelerometerModifier.setDistributor(accelerometerDistributor)

rotationDumpDistributor = d.SingleDistributor()
rotationDumper = jn.JsonDumpHandler()
rotationDumper.setDistributor(rotationDumpDistributor)
accelerometerDumpDistributor = d.SingleDistributor()
accelerometerDumper = jn.JsonDumpHandler()
accelerometerDumper.setDistributor(accelerometerDumpDistributor)

accelerometerWriter = term.FileWriter(accelerometerPath)
rotationWriter = term.FileWriter(rotationPath)

terminalDistributor.connect(loader)
loadDistributor.connect(accelerometerName, accelerometerModifier)
loadDistributor.connect(rotationName, rotationModifier)
rotationDistributor.connect(rotationDumper)
accelerometerDistributor.connect(accelerometerDumper)

rotationDumpDistributor.connect(rotationWriter)
accelerometerDumpDistributor.connect(accelerometerWriter)

terminal.startDistributing()
#+END_SRC
** variance
#+BEGIN_SRC python :tangle ../script/variance.py
<<include_source>>
import sys
import os
import numpy
import terminal
import observer
import encoder
import node
import strategy
import splitter

inputSubject = terminal.TerminalSubject()
jsonLoadNode = node.JsonLoadHandler()

varianceNode = node.StrategyNode(strategy.VarianceStrategy(initial = numpy.zeros(3)))
#splitter = splitter.SplitterBranchReplicator(headOfBranch = varianceNode)
#varianceNodeA = node.StrategyNode(strategy.VarianceStrategy(initial = numpy.zeros(3)))
#varianceNodeB = node.StrategyNode(strategy.VarianceStrategy(initial = numpy.zeros(3)))
#splitter.addNamedNode("MPL Accelerometer", varianceNodeA)
#splitter.addNamedNode("MPL Gyroscope", varianceNodeB)

jsonDumpNode = node.JsonDumpHandler(jsonEncoder = encoder.NumpyEncoder)
fileObserver = terminal.FileObserver(f"{os.path.dirname(sys.argv[1])}/variance")
stdoutObserver = terminal.StdoutObserver()

inputSubject.addObserver(jsonLoadNode)
jsonLoadNode.addObserver(splitter.SplitterBranchReplicator(headOfBranch = varianceNode))
varianceNode.addObserver(jsonDumpNode)
#varianceNodeA.addObserver(jsonDumpNode)
#varianceNodeB.addObserver(jsonDumpNode)
jsonDumpNode.addObserver(fileObserver)
jsonDumpNode.addObserver(stdoutObserver)

inputSubject.startNotifying()
#+END_SRC
** COMMENT streamServer(Log & File)                              :deprecated:
#+BEGIN_SRC python :tangle ../script/run_streamServer.py
<<include_source>>
import asyncio
import stream
import datetime

class LogStreamSubscriber(stream.StreamSubscriber):
    def update(self, packet: str):
        print(packet)

class FileStreamSubscriber(stream.StreamSubscriber):
    def __init__(self, file: str):
        self.output = open(file, "w+")
        
    def update(self, packet: str):
        self.output.write(packet)

        
jsonStream = stream.StreamPublisher()
subscriber = {
    "log": LogStreamSubscriber(),
    "csv": FileStreamSubscriber(file = f"output/{datetime.datetime.now():%Y-%m-%d_%H:%M:%S}")
}

jsonStream.addSubscriber(subscriber["log"])
jsonStream.addSubscriber(subscriber["csv"])

try:
    asyncio.run(jsonStream.start(port = 11772))
except KeyboardInterrupt:
    sys.exit(0)
#+END_SRC
* Scrap
** Fusing with Nested Class Observers                                :T712_1:
#+BEGIN_SRC python
import quaternion

class OrientedVectorNode:
    def __init__(self, quaternionState, vectorState):
        self.subject = Subject() #TODO dependency injection
        self.quaternionObserver = self.QuaternionObserver()
        self.vectorObserver = self.VectorObserver()

    class QuaternionObserver(observer.Observer):
        def onUpdateFromSubject(self, package):
            self.quaternion = 

    class VectorObserver(observer.Observer):
        def onUpdateFromSubject(self, package):

        
#+END_SRC
** alias matrix variable
#+BEGIN_SRC python :eval no-export
import numpy
import enum

class State(enum.IntEnum):
    position = 0
    velocity = 1
    
state = numpy.array([1, 2])
velocity = state[1]
position = state[0]
print("pos:", state[State.position])
print("vel:", state[State.velocity])

state[1] = 4
print("pos:", state[State.position])
print("vel:", state[State.velocity])
#+END_SRC

#+RESULTS[4799896116125a2a317139001fa4e057c69bf34c]:
: pos: 1
: vel: 2
: pos: 1
: vel: 4
** plane tracking (kalman)
#+BEGIN_SRC python :eval no-export
import numpy as np
from numpy.linalg import inv

x_observations = np.array([4000, 4260, 4550, 4860, 5110])
v_observations = np.array([280, 282, 285, 286, 290])

z = np.c_[x_observations, v_observations]

# Initial Conditions
a = 2  # Acceleration
v = 280
t = 1  # Difference in time

# Process / Estimation Errors
error_est_x = 20
error_est_v = 5

# Observation Errors
error_obs_x = 25  # Uncertainty in the measurement
error_obs_v = 6

def prediction2d(x, v, t, a):
    A = np.array([[1, t],
                  [0, 1]])
    X = np.array([[x],
                  [v]])
    B = np.array([[0.5 * t ** 2],
                  [t]])
    X_prime = A.dot(X) + B.dot(a)
    return X_prime


def covariance2d(sigma1, sigma2):
    cov1_2 = sigma1 * sigma2
    cov2_1 = sigma2 * sigma1
    cov_matrix = np.array([[sigma1 ** 2, cov1_2],
                           [cov2_1, sigma2 ** 2]])
    return np.diag(np.diag(cov_matrix))


# Initial Estimation Covariance Matrix
P = covariance2d(error_est_x, error_est_v)
A = np.array([[1, t],
              [0, 1]])

# Initial State Matrix
X = np.array([[z[0][0]],
              [v]])
n = len(z[0])

for data in z[1:]:
    X = prediction2d(X[0][0], X[1][0], t, a)
    # To simplify the problem, professor
    # set off-diagonal terms to 0.
    P = np.diag(np.diag(A.dot(P).dot(A.T)))

    # Calculating the Kalman Gain
    H = np.identity(n)
    R = covariance2d(error_obs_x, error_obs_v)
    S = H.dot(P).dot(H.T) + R
    K = P.dot(H).dot(inv(S))

    # Reshape the new data into the measurement space.
    Y = H.dot(data).reshape(n, -1)

    # Update the State Matrix
    # Combination of the predicted state, measured values, covariance matrix and Kalman Gain
    X = X + K.dot(Y - H.dot(X))

    # Update Process Covariance Matrix
    P = (np.identity(len(K)) - K.dot(H)).dot(P)
    print("X:", X)
    print("P:", P)

print("Kalman Filter State Matrix:\n", X)
#+END_SRC

#+RESULTS[563ec8fbda592c500f687496fc37cc4a01753429]:
#+begin_example
X: [[4272.5]
 [ 282. ]]
P: [[252.97619048   0.        ]
 [  0.          14.75409836]]
X: [[4553.85054707]
 [ 284.29069767]]
P: [[187.4378327    0.        ]
 [  0.          10.46511628]]
X: [[4844.15764332]
 [ 286.22522523]]
P: [[150.30854278   0.        ]
 [  0.           8.10810811]]
X: [[5127.05898493]
 [ 288.55147059]]
P: [[126.38282157   0.        ]
 [  0.           6.61764706]]
Kalman Filter State Matrix:
 [[5127.05898493]
 [ 288.55147059]]
#+end_example
*
** numpy ndarray
 #+BEGIN_SRC python :eval no-export
import numpy

A = numpy.eye(6)
A[0:3, 3:6] = 2*numpy.eye(3)
#A = numpy.hstack((numpy.array([*numpy.eye(3), *numpy.eye(3)*2]), numpy.array([*numpy.zeros([3,3]), *numpy.eye(3)])))
print(A)
 #+END_SRC

 #+RESULTS[c2fea3356f7ba157f983b21c8e180a9c84903dec]:
 : [[1. 0. 0. 2. 0. 0.]
 :  [0. 1. 0. 0. 2. 0.]
 :  [0. 0. 1. 0. 0. 2.]
 :  [0. 0. 0. 1. 0. 0.]
 :  [0. 0. 0. 0. 1. 0.]
 :  [0. 0. 0. 0. 0. 1.]]

** transpose 3x9
#+BEGIN_SRC python :eval no-export
import numpy
H = numpy.hstack((numpy.zeros((3, 6)), numpy.eye(3)))
print(H)
print(H.T);

#+END_SRC

#+RESULTS[990d6266bc08304c4e82ce6ea39ec984e1ae8318]:
#+begin_example
[[0. 0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 1.]]
[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
#+end_example

** stdin read continuously
#+BEGIN_SRC python :tangle ../scrap/run_stdinLoop.py
import sys

for line in sys.stdin:
    print(line)
#+END_SRC

** subject/observer
#+BEGIN_SRC python :tangle ../scrap/test_stdinToStdout.py
<<include_source>>
import terminal
s = terminal.TerminalSubject()
o = terminal.StdoutObserver()
s.addObserver(o)
s.startNotifying()
#+END_SRC

#+BEGIN_SRC python :tangle ../scrap/test_stdinToFile.py
<<include_source>>
import terminal
import sys
s = terminal.TerminalSubject()
o = terminal.FileObserver(f"{sys.argv[0]}_output")
s.addObserver(o)
s.startNotifying()
#+END_SRC

** quaternion hamiltonian product
#+BEGIN_SRC python :eval no-export
import numpy
w1 = 1
w2 = 10
a = numpy.array([1, 2, 3])
b = numpy.array([2, 3, 4])
c = a*b
print(w1*w2-sum(c))

print(sum(a**2))

#+END_SRC

#+RESULTS[e19a4225ef6cb94074f406f493ba41c941abb820]:
: -10
: 14

** dict from list
#+BEGIN_SRC python :eval no-export
l = ["A", "B"]
d = {i: None for i in l}
print(d)

d = dict.fromkeys(l)
print(d)
#+END_SRC

#+RESULTS[420b00e48f63f7ae914bd04b0137135ba2400479]:
: {'A': None, 'B': None}
: {'A': None, 'B': None}

** clear dict values
#+BEGIN_SRC python :eval no-export
d = {"A": 1, "B": 2}
d = dict.fromkeys(d)
print(d)
#+END_SRC

#+RESULTS[d0c2a8905c7aa127e44889b5784960c338a222a2]:
: {'A': None, 'B': None}

** list from list (checking numpy array compatability)
#+BEGIN_SRC python :eval no-export
import numpy
vector = [1, 2, 3]
a = list(vector)
b = numpy.array(vector)
print(a)
print(b)
#+END_SRC

#+RESULTS[ad06cfbafab1c9bc9dac16ae92c212c99d84b011]:
: [1, 2, 3]
: [1 2 3]

** list from list and value
#+BEGIN_SRC python :eval no-export
a = [1, 2, 3]
b = 4.3
c = list([*a, b])
print(c)

import numpy
a = numpy.asarray(a)
c = numpy.array([*a, b])
print(c)
#+END_SRC

#+RESULTS[46e762ce8de75bca8876337649aa6ce502640afb]:
: [1, 2, 3, 4.3]
: [1.  2.  3.  4.3]

** cast list to float
#+BEGIN_SRC python :eval no-export
x = [5.4]
y = (1, 3, 5)
a = float(*x)
b = list(*y)
print(a)
print(y)
#+END_SRC

#+RESULTS[cf336f99ddc9779b7fd068e69854f37abeaa9540]:

* Other
#+name: include_source
#+BEGIN_SRC python
import sys
sys.path.append("../source")
#+END_SRC
