#+property: header-args :dir ../source/ :cache yes :noweb yes :exports code :eval no :results output
#+options: toc:nil num:nil

#+title: Sensor Port 
#+author: Lewis Collum

*** Tasks [2/6]
**** DONE Nodes need to handle multiple inputs                       :T712_1:
	 CLOSED: [2019-07-21 Sun 00:13]
**** DONE Nodes with feedback capabilities                           :T712_2:
	 CLOSED: [2019-07-21 Sun 00:13] Joiners allow feedback
**** TODO Kalman Expectation Maximization algorithm for covariance matrices :T715_1:
**** TODO Extract input type from TerminalDistributor then make a Factory for deciding input type :T719_1:terminal:
**** TODO Extract ~package.setdefault("strategies", []).append(self.strategy.__class__.__name__~ from =node= :T720_1:node:
**** TODO Allow user to choose what type of buffering he wants in Joiner :T721_1:joiner:
	 - ~self.joinables = dict.fromkeys(self.joinables)~ clears the "buffer".
* Modules
** handler
*** source
#+BEGIN_SRC python :tangle ../source/handler.py
import abc

class Handler(abc.ABC):
    @abc.abstractmethod
    def onReceivedPackage(self, package): pass

    @abc.abstractmethod
    def onConnected(self): pass
    
    @abc.abstractmethod
    def onDisconnected(self): pass
#+END_SRC
*** mock
#+BEGIN_SRC python :tangle ../source/mock_handler.py
import handler

class MockHandler(handler.Handler):
    def __init__(self):
        self.wasConnected = False
        self.wasDisconnected = False
        self.package = None
        
    def onReceivedPackage(self, package): self.package = package
    def onConnected(self): self.wasConnected = True
    def onDisconnected(self): self.wasDisconnected = True
#+END_SRC
** distributor
*** source
#+BEGIN_SRC python :tangle ../source/distributor.py
import abc
import handler

class Distributor(abc.ABC):
    @abc.abstractmethod
    def distribute(self, package): pass
    
    @abc.abstractmethod
    def connect(self, handler: handler.Handler): pass

    @abc.abstractmethod
    def disconnect(self): pass

    
class MultiDistributor(Distributor):
    def __init__(self):
        self.handlers = []

    def connect(self, handler: handler.Handler):
        self.handlers.append(handler)
        handler.onConnected()
        
    def distribute(self, package):
        for handler in self.handlers:
            handler.onReceivedPackage(package)

    def disconnect(self):
        for handler in self.handlers:
            handler.onDisconnected()
        self.handlers.clear()


class SingleDistributor(Distributor):
    def connect(self, handler: handler.Handler):
        self.handler = handler
        self.handler.onConnected()
        
    def distribute(self, package):
        self.handler.onReceivedPackage(package)

    def disconnect(self):
        self.handler.onDisconnected()
        self.handler = None   
#+END_SRC
*** test
#+BEGIN_SRC python :tangle ../source/test_distributor.py
import unittest
import distributor
import mock_distributor
import mock_handler

class TestSingleDistributor(unittest.TestCase):
    def setUp(self):
        self.handler = mock_handler.MockHandler()
        self.distributor = distributor.SingleDistributor()
        self.distributor.connect(self.handler)
        
    def test_distributeToSingleHandler(self):
        expected = "abc"
        self.distributor.distribute(expected)
        actual = self.handler.package
        self.assertEqual(actual, expected)
        
    def test_connectToHandler(self):
        self.assertTrue(self.handler.wasConnected)
        
    def test_disconnectFromHandler(self):
        self.distributor.disconnect()
        self.assertTrue(self.handler.wasDisconnected)


class TestMultiDistributor(unittest.TestCase):
    def setUp(self):
        self.handlerA = mock_handler.MockHandler()
        self.handlerB = mock_handler.MockHandler()
        self.distributor = distributor.MultiDistributor()
        self.distributor.connect(self.handlerA)
        self.distributor.connect(self.handlerB)
        
    def test_distributeToMultipleHandlers(self):
        expected = "abc"
        self.distributor.distribute(expected)

        actualA = self.handlerA.package
        actualB = self.handlerB.package
        
        self.assertEqual(actualA, expected)
        self.assertEqual(actualB, expected)
        
    def test_connectToHandlers(self):
        self.assertTrue(self.handlerA.wasConnected)
        self.assertTrue(self.handlerB.wasConnected)
        
    def test_disconnectFromHandlers(self):
        self.distributor.disconnect()

        self.assertTrue(self.handlerA.wasDisconnected)
        self.assertTrue(self.handlerB.wasDisconnected)
        
if __name__ == '__main__':
    unittest.main()
#+END_SRC
*** mock
#+BEGIN_SRC python :tangle ../source/mock_distributor.py
import distributor
import handler

class MockDistributor(distributor.Distributor):
    def connect(self, handler: handler.Handler): self.handler = handler
    def distribute(self, package): self.handler.onReceivedPackage(package)
    def disconnect(self): pass
#+END_SRC
** terminal
*** source
#+BEGIN_SRC python :tangle ../source/terminal.py
import sys
import handler
import distributor as d
class TerminalDistributor:
    def __init__(self, distributor: d.Distributor):
        self.distributor = distributor
        self.terminalInput = open(sys.argv[1]) if len(sys.argv) > 1 else sys.stdin

    def connect(self, handler: handler.Handler):
        self.distributor.connect(handler)
        
    def startDistributing(self):
        for line in self.terminalInput:
            self.distributor.distribute(line)
        self.distributor.disconnect()


class FileWriter(handler.Handler):
    def __init__(self, fileName: str):
        self.fileName = fileName

    def onConnected(self):
        self.output = open(self.fileName, "w+")
    
    def onReceivedPackage(self, package: str):
        self.output.write(package)
        if not package.endswith('\n'):
            self.output.write('\n')

    def onDisconnected(self):
        self.output.close()
    

class StdoutWriter(handler.Handler):
    def onReceivedPackage(self, package: str):
        print(package)        

    def onConnected(self): pass
    def onDisconnected(self): pass
#+END_SRC
** node
*** source
#+BEGIN_SRC python :tangle ../source/node.py
import strategy
import json
import abc
import distributor
import handler
import package as pk

class Node(handler.Handler): 
    def __init__(self, distributor: distributor.Distributor):
        self.distributor = distributor

    def onReceivedPackage(self, package):
        self.distributor.distribute(self.handlePackage(package))

    @abc.abstractmethod
    def handlePackage(self, package): pass


class StrategyNode(Node):
    def __init__(self, distributor: distributor.Distributor, strategy: strategy.Strategy):
        super(StrategyNode, self).__init__(distributor)
        self.strategy = strategy

    def handlePackage(self, package):
        package.values = self.strategy.execute(input = package.values)
        return package

class JsonLoadNode(Node):
    def handlePackage(self, package):
        return json.loads(package)

    def onConnected(self): pass
    def onDisconnected(self): pass
    
class JsonDumpNode(Node):
    def __init__(self, distributor: distributor.Distributor, jsonEncoder = None):
        super(JsonDumpNode, self).__init__(distributor)
        self.jsonEncoder = jsonEncoder

    def handlePackage(self, package):
        return json.dumps(package, cls = self.jsonEncoder)

    def onConnected(self): pass
    def onDisconnected(self): pass

class PackagingNode(Node):
    def handlePackage(self, package: dict):
        return pk.Package(package)

    def onConnected(self): pass
    def onDisconnected(self): pass
#+END_SRC
*** test
#+BEGIN_SRC python :tangle ../source/test_node.py
import unittest
import mock_distributor
import mock_associative_distributor
import mock_node
import mock_handler
import mock_package
import package

class TestNode(unittest.TestCase):
    def setUp(self):
        self.packageDistributor = mock_distributor.MockDistributor()
        self.nodeDistributor = mock_distributor.MockDistributor()
        self.node = mock_node.MockNode(distributor = self.nodeDistributor)
        self.packageReceiver = mock_handler.MockHandler()

        self.packageDistributor.connect(self.node)
        self.nodeDistributor.connect(self.packageReceiver)

    def test_packageReceivedFromDistributor(self):
        package = "abc"
        self.packageDistributor.distribute(package)

        actualPackage = self.packageReceiver.package
        
        self.assertEqual(actualPackage, package)

if __name__ == '__main__':
    unittest.main()
#+END_SRC
*** mock
#+BEGIN_SRC python :tangle ../source/mock_node.py
import node

class MockNode(node.Node):
    def handlePackage(self, package): return package
    def onConnected(self): pass
    def onDisconnected(self): pass
#+END_SRC
** strategy
*** source
#+BEGIN_SRC python :tangle ../source/strategy.py
import pair 
import abc

class Strategy(abc.ABC):
    @abc.abstractmethod
    def execute(self, input): pass
            
class VarianceStrategy(Strategy):
    def __init__(self, initial):
        self.mean = pair.Pair(initial = initial)
        self.variance = initial
        self.count = 0

    def execute(self, input):
        self.mean.shift()
        self.count += 1
        deviation = input - self.mean.previous
        self.mean.offsetFromPrevious(deviation/self.count)
        deviationCurrent = input - self.mean.current
        self.variance += deviation*deviationCurrent
        return self.variance/self.count

#+END_SRC
*** mock
#+BEGIN_SRC python :tangle ../source/mock_strategy.py
import strategy

class MockStrategy(strategy.Strategy):
    def execute(self, input):
        return input
#+END_SRC
** package
*** source
#+BEGIN_SRC python :tangle ../source/package.py
import abc 

class PackageConfig:
    name = "name"
    value = "value"
    timestamp = "timestamp"
    
class Package:
    def __init__(self, package: dict):
        self.package = package

    @property
    def name(self):
        return self.package[PackageConfig.name]
        
    @property
    def value(self):
        return self.package[PackageConfig.value]
    
    @value.setter
    def value(self, value):
        self.package[PackageConfig.value] = value

    @property
    def timestamp(self):
        return self.package[PackageConfig.timestamp]
    
    @classmethod
    def make(cls, name: str = None, timestamp: int = None, value = None):
        return cls({PackageConfig.name: name, PackageConfig.value: value, PackageConfig.timestamp: timestamp})

    @classmethod
    def nameFromPackage(cls, package):
        return package.name
    
    @classmethod
    def valueFromPackage(cls, package):
        return package.value

    @classmethod
    def timestampFromPackage(cls, package):
        return package.timestamp
    
    
class PackageValue(abc.ABC):
    containerClass = tuple
    
    def __init__(self, values):
        self.values = values
        
    @classmethod
    def fromContainer(cls, values):
        if values.__class__ == PackageValue.containerClass:
            return cls(values) 
        return cls(cls.containerClass(values))
#+END_SRC
*** mock
#+BEGIN_SRC python :tangle ../source/mock_package.py
import package as pk

class MockPackageValue(pk.PackageValue):
    @classmethod
    def fromContainer(cls, container): pass
#+END_SRC
** package_imu
*** source
#+BEGIN_SRC python :tangle ../source/package_imu.py
import package as pk

class Vector3D(pk.PackageValue):
    @property
    def x(self):
        return self.values[0]
    
    @property
    def y(self):
        return self.values[1]
    
    @property
    def z(self):
        return self.values[2]
            
    @classmethod
    def fromComponents(cls, x, y, z):
        return cls.fromContainer(values = (x, y, z))
    

class Quaternion(pk.PackageValue):
    @property
    def vector(self):
        return self.values[0:3]

    @property
    def scalar(self):
        return self.values[3]
        
    @classmethod
    def fromComponents(cls, x, y, z, scalar):
        vector = Vector3D.fromComponents(x, y, z)
        return cls.fromContainer(values = (x, y, z, scalar))
#+END_SRC
*** test
#+BEGIN_SRC python :tangle ../source/test_package_imu.py
import package as pk
import package_imu as pk_imu
import unittest

class TestVector3D(unittest.TestCase):
    def setUp(self):
        self.expected = (1, 2, 3)
        
    def test_fromContainer_vectorMatches(self):
        vector = pk_imu.Vector3D.fromContainer(self.expected)

        self.assertEqual(self.expected, vector.values)

    def test_fromComponents_vectorMatches(self):
        x, y, z = self.expected
        vector = pk_imu.Vector3D.fromComponents(x, y, z)

        self.assertEqual(self.expected, vector.values)


class TestQuaternion(unittest.TestCase):
    def setUp(self):
        self.expected = (1, 2, 3, 0)

    def test_fromContainer_valuesMatch(self):
        quaternion = pk_imu.Quaternion.fromContainer(self.expected)

        self.assertEqual(self.expected, quaternion.values)
        
    def test_fromComponents_valuesMatch(self):
        x, y, z, scalar = self.expected
        quaternion = pk_imu.Quaternion.fromComponents(x, y, z, scalar)

        self.assertEqual(self.expected, quaternion.values)

if __name__ == '__main__':
    unittest.main()
#+END_SRC
** associative_distributor
*** source
#+BEGIN_SRC python :tangle ../source/associative_distributor.py
import distributor
import handler
import abc
import package as pk

class AssociativeDistributor(distributor.Distributor):
    @abc.abstractmethod
    def connect(self, name: str, handler: handler.Handler): pass
    
        
class KeyDistributor(AssociativeDistributor):
    def __init__(self):
        self.handlers = {}

    def connect(self, name: str, handler: handler.Handler):
        self.handlers.setdefault(name, []).append(handler)
        handler.onConnected()
        
    def distribute(self, package):
        for handler in self.handlers[package.name]:
            handler.onReceivedPackage(package)

    def disconnect(self):
        for name, handlers in self.handlers.items():
            for handler in handlers:
                handler.onDisconnected()
        self.handlers.clear()    
#+END_SRC
*** test
#+BEGIN_SRC python :tangle ../source/test_associative_distributor.py
import unittest
import associative_distributor
import mock_handler
import mock_package as mock_pk
import package as pk

class TestKeyDistributor(unittest.TestCase):
    def setUp(self):
        self.distributor = associative_distributor.KeyDistributor()
        self.handler = mock_handler.MockHandler()

        self.distributor.connect("A", self.handler)
        
    def test_distributeToMultipleHandlers(self):
        expectedPackage = pk.Package.make(name = "A")
        self.distributor.distribute(expectedPackage)

        actualPackage = self.handler.package
        
        self.assertEqual(actualPackage, expectedPackage)
        
    def test_connectToHandlers(self):
        self.assertTrue(self.handler.wasConnected)
        
    def test_disconnectFromHandlers(self):
        self.distributor.disconnect()

        self.assertTrue(self.handler.wasDisconnected)


if __name__ == '__main__':
    unittest.main()
#+END_SRC
*** mock
#+BEGIN_SRC python :tangle ../source/mock_associative_distributor.py
import associative_distributor
import handler
import package as pk

class MockAssociativeDistributor(associative_distributor.AssociativeDistributor):
    def __init__(self): self.handler = {}
    def connect(self, name: str, handler: handler.Handler): self.handler[name] = handler
    def distribute(self, package): self.handler[package.name].onReceivedPackage(package)
    def disconnect(self): pass
#+END_SRC
** splitter
*** source
#+BEGIN_SRC python :tangle ../source/splitter.py
import handler
import node
import associative_distributor as ad
import package as pk

class Splitter(node.Node):
    def handlePackage(self, package): return package
    def onConnected(self): pass
    def onDisconnected(self): pass

class PackageSplitter(node.Node):
    def __init__(self, distributor: ad.AssociativeDistributor):
        super(PackageSplitter, self).__init__(distributor)
        self.packageClasses = {}
        
    def handlePackage(self, package):
        package = pk.Package(package)
        package.value = self.packageClasses[package.name](package.value)
        return package

    def addPackageClass(self, name: str, cls: pk.PackageValue):
        self.packageClasses[name] = cls
        
    def onConnected(self): pass
    def onDisconnected(self): pass
    
#+END_SRC
*** test
#+BEGIN_SRC python :tangle ../source/test_splitter.py
import unittest
import splitter
import mock_associative_distributor as mock_ad
import mock_distributor as mock_d
import mock_handler
import package as pk
import mock_package as mock_pk

class TestSplitter(unittest.TestCase):
    def setUp(self):
        self.A = mock_handler.MockHandler()
        self.B = mock_handler.MockHandler()

        self.distributor = mock_ad.MockAssociativeDistributor()
        self.distributor.connect("A", self.A)
        self.distributor.connect("B", self.B)

        self.packageDistributor = mock_d.MockDistributor()
        self.splitter = splitter.Splitter(self.distributor)
        self.packageDistributor.connect(self.splitter)        
        
    def test_distribute_packageSentToANotB(self):
        packageForA = pk.Package.make(name = "A")
        self.packageDistributor.distribute(packageForA)

        self.assertEqual(packageForA, self.A.package)
        self.assertEqual(None, self.B.package) 

if __name__ == '__main__':
    unittest.main()
#+END_SRC
** joiner
*** source
#+BEGIN_SRC python :tangle ../source/joiner.py
import node
import abc
import distributor as d


class Joiner(node.Node):
    def __init__(self, distributor: d.Distributor):
        super(Joiner, self).__init__(distributor)
        self.joinables = {}
        self.name = None
        
    def handlePackage(self, package):
        joined = self.join(self.joinables)
        self.joinables = dict.fromkeys(self.joinables)
        return joined

    #TODO REMOVE HACK 
    def onReceivedPackage(self, package):
        self.joinables[package.name] = package
        if None not in self.joinables.values(): 
            self.distributor.distribute(self.handlePackage(package))
    
    def addJoinableName(self, name: str):
        self.joinables[name] = None

    def addJoinableNames(self, *names):
        for name in names:
            self.joinables[name] = None
        
    def removeJoinableName(self, name: str):
        del self.joinables[name]

    @abc.abstractmethod
    def join(self, joinables: dict): pass
#+END_SRC
*** test
#+BEGIN_SRC python :tangle ../source/test_joiner.py
import unittest
import mock_joiner
import mock_distributor as mock_d
import mock_handler
import mock_package as mock_pk
import package as pk

class TestJoiner(unittest.TestCase):
    def setUp(self):
        self.distributorA = mock_d.MockDistributor()
        self.distributorB = mock_d.MockDistributor()
        self.adderDistributor = mock_d.MockDistributor()
        self.adder = mock_joiner.MockAddJoiner(self.adderDistributor)
        self.adder.addJoinableNames("A", "B")
        self.packageReceiver = mock_handler.MockHandler()

        self.distributorA.connect(self.adder)
        self.distributorB.connect(self.adder)
        self.adderDistributor.connect(self.packageReceiver)

    def test_handlerReceivesFusedJoinerOutput(self):
        packageA = pk.Package.make(name = "A", value = 1)
        packageB = pk.Package.make(name = "B", value = 2)
        expectedSum = packageA.value + packageB.value
        self.distributorA.distribute(packageA)
        self.distributorB.distribute(packageB)

        self.assertEqual(self.packageReceiver.package.value, expectedSum)

if __name__ == '__main__':
    unittest.main()
#+END_SRC
*** mock
#+BEGIN_SRC python :tangle ../source/mock_joiner.py
import joiner
import distributor
import package as pk

class MockAddJoiner(joiner.Joiner):
    def join(self, joinables): return pk.Package.make(name = self.name, value = sum(package.value for package in joinables.values()))
    def onConnected(self): pass
    def onDisconnected(self): pass
#+END_SRC
** imu
*** source
#+BEGIN_SRC python :tangle ../source/imu.py
import joiner
import distributor
import quaternion as quat
import package as pk
import package_imu as pk_imu

class QuaternionVectorJoiner(joiner.Joiner):
    def join(self, joinables):
        quaternion = quat.Quaternion(
            joinables[self.quaternionName].value.vector,
            joinables[self.quaternionName].value.scalar)

        vector = quaternion.rotateVector(joinables[self.vectorName].value.values)
        value = pk_imu.Vector3D.fromContainer(vector)
        timestamp = int((joinables[self.quaternionName].timestamp + joinables[self.quaternionName].timestamp)/2)
        return pk.Package.make(name=self.name, value=value, timestamp=timestamp)
    
    def addQuaternionName(self, name: str):
        self.quaternionName = name
        self.addJoinableName(name)

    def addVectorName(self, name: str):
        self.vectorName = name
        self.addJoinableName(name)

    def onConnected(self): pass
    def onDisconnected(self): pass
#+END_SRC
*** test
#+BEGIN_SRC python :tangle ../source/test_imu.py
import unittest
import imu
import mock_distributor
import mock_handler
import package_imu as pk_imu
import package as pk

class TestQuaternionVectorJoiner(unittest.TestCase):
    def setUp(self):
        self.vectorDistributor = mock_distributor.MockDistributor()
        self.quaternionDistributor = mock_distributor.MockDistributor()
        self.joinerDistributor = mock_distributor.MockDistributor()
        self.joiner = imu.QuaternionVectorJoiner(self.joinerDistributor)
        self.receiver = mock_handler.MockHandler()

        self.joiner.addQuaternionName("Quaternion")
        self.quaternionDistributor.connect(self.joiner)
        self.joiner.addVectorName("Vector")
        self.vectorDistributor.connect(self.joiner)
        self.joinerDistributor.connect(self.receiver)
        
    def test_receivedRotatedVector(self):
        vectorPackage = pk.Package.make(
            name="Vector",
            value=pk_imu.Vector3D.fromComponents(x=1,y=0,z=0),
            timestamp=1)
        quaternionPackage = pk.Package.make(
            name="Quaternion",
            value=pk_imu.Quaternion.fromComponents(x=0,y=0,z=1,scalar=0),
            timestamp=3)
        self.vectorDistributor.distribute(vectorPackage)
        self.quaternionDistributor.distribute(quaternionPackage)

        expected = pk_imu.Vector3D.fromComponents(x=-1,y=0,z=0).values
        actual = self.receiver.package.value.values
        self.assertEqual(expected, actual)

if __name__ == '__main__':
    unittest.main()        
#+END_SRC
** pair
#+BEGIN_SRC python :tangle ../source/pair.py
class Pair:
    def __init__(self, initial = None):
        self.pair = [None, initial]
        
    def shift(self, new = None):
        self.pair[0] = self.pair[1]
        self.pair[1] = new

    def offsetFromPrevious(self, offset):
        self.pair[1] = self.pair[0] + offset
                
    @property
    def current(self):
        return self.pair[1]

    @property
    def previous(self):
        return self.pair[0]

    @property
    def difference(self):
        return self.pair[1] - self.pair[0]
#+END_SRC
** quaternion
*** source
#+BEGIN_SRC python :tangle ../source/quaternion.py    
import copy

class Quaternion:
    normalizingStrategy = None
    
    def __init__(self, vector, scalar):        
        self.vector = vector
        self.scalar = scalar
        
    def rotateVector(self, vector):
        quaternionFromVector = Quaternion(vector=vector, scalar=0)
        resultantQuaternion = self * quaternionFromVector * self.conjugate()
        return resultantQuaternion.vector
        
    def conjugate(self):
        conjugatedVector = self.vector.__class__((-i for i in self.vector))
        return Quaternion(vector=conjugatedVector, scalar=self.scalar)
        
    def __mul__(self, other):
        b1, c1, d1 = self.vector
        a1 = self.scalar
        b2, c2, d2 = other.vector
        a2 = other.scalar

        w = a1*a2 - b1*b2 - c1*c2 - d1*d2
        x = a1*b2 + b1*a2 + c1*d2 - d1*c2
        y = a1*c2 - b1*d2 + c1*a2 + d1*b2
        z = a1*d2 + b1*c2 - c1*b2 + d1*a2
        return Quaternion(vector=self.vector.__class__([x, y, z]), scalar=w)
    
    def normalize(self):
        Quaternion.normalizingStrategy(self)
#+END_SRC
*** documentation
   Two quaternions, that represent two distinct rotations, can be
   multiplied together to get a single, resultant, rotation
   (https://en.wikipedia.org/wiki/Quaternion#Hamilton_product). This
   property allows a quaternion to be applied to a vector
   (e.g. acceleration) by "conjugating" the quaternion by the vector
   ([[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Using_quaternion_as_rotations]]).

   In the class ~Quaternion~, the multiplication operator, ~__mul__~,
   is overloaded to represent Hamiltonian multiplication.
   
   Quaternions can be applied to vectors, via "conjugation", using
   ~applyToVector~.
*** test
#+BEGIN_SRC python :tangle ../source/test_quaternion.py
import unittest
import quaternion

class TestQuaternion(unittest.TestCase):

    def test_rotateListVector(self):
        self.quaternion = quaternion.Quaternion((0, 0, 0), 1)        

if __name__ == '__main__':
    unittest.main()
#+END_SRC
** encoder
 #+BEGIN_SRC python :tangle ../source/encoder.py
import json
import numpy
import package as pk

class NumpyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, numpy.ndarray):
            return obj.tolist()
        return json.JSONEncoder.default(self, obj)

class PackageEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, pk.Package):
            return obj.package
        elif isinstance(obj, pk.PackageValue):
            return obj.values
 #+END_SRC
** COMMENT categorizer
#+BEGIN_SRC python :tangle ../source/categorizer.py
class Categorizer:
    def __init__(self, keysToKeep: list):
        self.categorized = {}
        self.keys = keysToKeep
        
    def categorizeLine(self, line: dict):
        name = line["name"]
        if name not in self.categorized:
            self.categorized[name] = {}
            for key in self.keys:
                self.categorized[name][key] = []
                
        for key in self.keys:
            self.categorized[name][key].append(line[key])

    def items(self):
        return self.categorized.items()
#+END_SRC

** COMMENT handler
#+BEGIN_SRC python
class Handler(observer.Observer):
    def __init__(self, name: str, subject, successor: Handler):
        self.subject = subject
        self.successor = successor

    def onUpdateFromSubject(self, package):
        if package[self.name] == self.name:
            self.handle(package)
        else:
            self.forward(package)

    def handle(self, package):
        self.subject.notifySubscribers(package)

    def forward(self, package):
        if self.successor != None:
            self.successor.onUpdateFromSubject(package)
#+END_SRC

** COMMENT stream                                                :deprecated:
#+BEGIN_SRC python :tangle ../source/stream.py :eval no-export
import asyncio
import ip

class StreamSubscriber:
    def update(self, packet: str):
        pass

    def shutdown(self):
        pass

class StreamPublisher:
    def __init__(self):
        self.subscribers = []
        
    def addSubscriber(self, subscriber: StreamSubscriber):
        self.subscribers.append(subscriber)

    def removeSubscriber(self, subscriber: StreamSubscriber):
        self.subscribers.remove(subscriber)

    def sendPacket(self):
        for subscriber in self.subscribers:
            subscriber.update(self.packet)

    def sendShutdown(self):
        for subscriber in self.subscribers:
            subscriber.shutdown()

    async def handler(self, reader, writer):
        while not reader.at_eof():
            self.packet = (await reader.readline()).decode('utf-8')
            self.sendPacket()

        self.sendShutdown()

    async def start(self, port):
        self.server = await asyncio.start_server(self.handler, ip.local(), port)
        async with self.server:
            await self.server.serve_forever()
#+END_SRC
** COMMENT ip                                                    :deprecated:
#+BEGIN_SRC python :tangle ../source/ip.py
import subprocess

<<ip.local>>
#+END_SRC

#+name: ip.local
#+BEGIN_SRC python
def local():
    command = 'ip addr | grep "global" | egrep -o "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | head -n1'
    process = subprocess.run(command, shell=True, check=True, encoding='utf-8', stdout=subprocess.PIPE)
    ip = process.stdout.split()
    if not ip: raise RuntimeError("No Network Connection")
    return ip[0]
#+END_SRC

#+BEGIN_SRC python :eval no-export
import ip
print(ip.local())
#+END_SRC

#+RESULTS[9ab9e9195a7e776c05bb1649a5967ef8e84217de]:
: 192.168.0.101

* Scripts
** applyKalman
#+BEGIN_SRC python :tangle ../script/run_applyKalman.py
<<include_source>>
import sys
import json
import numpy
import matplotlib.pyplot as pyplot
import pykalman
import pair
import enum
import datetime
import fileinput

import node
import terminal
import observer

class State:
    size = 9
    dimensions = 3
    
    class Position(enum.IntEnum):
        x, y, z = 0, 1, 2

    class Velocity(enum.IntEnum):
        x, y, z = 3, 4, 5

    class Acceleration(enum.IntEnum):
        x, y, z = 6, 7, 8
        

state = numpy.zeros(State.size)
stateModel = numpy.eye(9)
measurement = numpy.zeros(State.dimensions)
measurementModel = numpy.hstack((numpy.zeros((State.dimensions, State.size-State.dimensions)), numpy.eye(State.dimensions)))
stateVariance = 0 #numpy.eye(State.size)*0.0005
measurementVariance = numpy.eye(State.dimensions)*0.0005
processVariance = numpy.eye(State.size)


# class KalmanNode(observer.Subject, observer.Observer):
#     def __init__(self, state

# terminalSubject = terminal.TerminalSubject()

inputSubject = terminal.TerminalSubject()
jsonLoadNode = node.JsonLoadNode()

#handleNode = HandleNode(handlers = [LinearAccelerationHandler, QuaternionHandler])


for sample in fileinput.input():
    if fileinput.isfirstline():
        initial = json.loads(sample)
        seconds = TimePair(initial = initial["millis"]/1000)
        acceleration = numpy.asarray(initial["values"])

        if fileinput.isstdin():
            output = sys.stdout
        else:
            output = open(f"output/fused_{sys.argv[1]}_on_{datetime.datetime.now():%Y-%m-%d_%H:%M:%S}", "w+")
    else:
        sensor = json.loads(sample)
        seconds.shift(sensor["millis"]/1000)
        measurement = numpy.asarray(sensor["values"])

        first = numpy.eye(State.dimensions)*seconds.difference
        second = numpy.eye(State.dimensions)*seconds.difference**2/2
        stateModel[0:3,3:6] = first
        stateModel[0:3,6:9] = second
        stateModel[3:6,6:9] = first

        state = stateModel.dot(state)
        processVariance = stateModel.dot(processVariance).dot(stateModel.T) + stateVariance
        s = measurementModel.dot(processVariance).dot(measurementModel.T) + measurementVariance
        gain = processVariance.dot(measurementModel.T).dot(numpy.linalg.inv(s))
        #gain = numpy.hstack((numpy.zeros((State.dimensions, State.size-State.dimensions)), numpy.eye(State.dimensions))).T

        state = state + gain.dot(measurement - measurementModel.dot(state))
        processVariance = processVariance - gain.dot(measurementModel).dot(processVariance)
        
        output.write(json.dumps({
            "name": "Meters",
            "millis": seconds.current,
            "values": [state[State.Position.x],state[State.Position.y],state[State.Position.z]]}))
        output.write('\n')
        
        output.write(json.dumps({
            "name": "Meters/Seconds",
            "millis": seconds.current,
            "values": [state[State.Velocity.x],state[State.Velocity.y],state[State.Velocity.z]]}))
        output.write('\n')
        
        output.write(json.dumps({
            "name": "Meters/Second/Second",
            "millis": seconds.current,
            "values": [state[State.Acceleration.x],state[State.Acceleration.y],state[State.Acceleration.z]]}))
        output.write('\n')
        
output.close()









#+END_SRC
** imu
#+BEGIN_SRC python :tangle ../script/run_imu.py
<<include_source>>
import distributor as d
import terminal as term
import associative_distributor as ad
import splitter
import imu
import node
import package as pk
import package_imu as pk_imu
import encoder
import os

pk.PackageConfig.timestamp = "millis"
pk.PackageConfig.value = "values"

terminalDistributor = d.SingleDistributor()
jsonLoadDistributor = d.SingleDistributor()
#packageDistributor = d.SingleDistributor()
splitDistributor = ad.KeyDistributor()
imuDistributor = d.SingleDistributor()
jsonDumpDistributor = d.MultiDistributor()

#how to name node vs handler vs joiner, splitter? Too many names
#better name for TerminalDistributor
terminal = term.TerminalDistributor(terminalDistributor)
jsonLoadNode = node.JsonLoadNode(jsonLoadDistributor)
packageSplitter = splitter.PackageSplitter(splitDistributor)
#packagingNode = node.PackagingNode(packageDistributor)
#splitNode = splitter.Splitter(splitDistributor)
imuNode = imu.QuaternionVectorJoiner(imuDistributor)
jsonDumpNode = node.JsonDumpNode(jsonDumpDistributor, encoder.PackageEncoder)
stdoutWriter = term.StdoutWriter()
fileWriter = term.FileWriter(f"{os.path.dirname(sys.argv[1])}/imu")

acceleration = "Linear Acceleration"
rotation = "Rotation Vector"

#refactor here
packageSplitter.addPackageClass(rotation, pk_imu.Quaternion)
packageSplitter.addPackageClass(acceleration, pk_imu.Vector3D)

terminalDistributor.connect(jsonLoadNode)
jsonLoadDistributor.connect(packageSplitter)
#packageDistributor.connect(splitNode)
splitDistributor.connect(acceleration, imuNode)
splitDistributor.connect(rotation, imuNode)
imuDistributor.connect(jsonDumpNode)
jsonDumpDistributor.connect(stdoutWriter)
jsonDumpDistributor.connect(fileWriter)

imuNode.addQuaternionName(rotation)
imuNode.addVectorName(acceleration)

terminal.startDistributing()

#needs to be a way to not distribute every time
#+END_SRC
** record
#+BEGIN_SRC python :tangle ../script/record.py
<<include_source>>
import terminal as term
from datetime import datetime
import os
import distributor as d

timeOfRecording = f"{datetime.now():%Y-%m-%d_%H:%M:%S}"
os.makedirs("output/" + timeOfRecording)

terminal = term.TerminalDistributor(distributor = d.MultiDistributor())
stdoutWriter = term.StdoutWriter()
fileWriter = term.FileWriter(f"output/{timeOfRecording}/raw")

terminal.connect(stdoutWriter)
terminal.connect(fileWriter)
terminal.startDistributing()
#+END_SRC
** plot
#+BEGIN_SRC python :tangle ../script/plot.py
import matplotlib.pyplot as pyplot
import json
import sys
import re

class SensorPlotable:
    def __init__(self):
        self.values = []
        self.seconds = []

    def update(self, seconds: float, values: list):
        self.values.append(values)
        self.seconds.append(seconds)
        

class SensorPlotableManager:
    def __init__(self, title: str):
        self.sensors = {}
        self.title = title
        
    def update(self, name: str, seconds: float, values: list):
        if name not in self.sensors:
            self.sensors[name] = SensorPlotable()
        self.sensors[name].update(seconds, values)

    def plotAll(self):
        figure, axes = pyplot.subplots(nrows = len(self.sensors), squeeze = False, sharex = True)
        
        axes[0, 0].set_title(self.title)
        axes[len(self.sensors)-1, 0].set_xlabel("time (ms)")
        
        for i, (name, plotable) in enumerate(self.sensors.items()):
            axes[i, 0].set_ylabel(name)
            axes[i, 0].plot([i-plotable.seconds[0] for i in plotable.seconds], plotable.values)
                
        figure.tight_layout()
        pyplot.show()

        
manager = SensorPlotableManager(title = re.sub("^.*/", "", sys.argv[1]))
with open(sys.argv[1]) as jsonFile:
    for line in jsonFile:
        sample = json.loads(line)
        manager.update(sample["name"], sample["millis"], sample["values"])

manager.plotAll()
#+END_SRC

** variance
#+BEGIN_SRC python :tangle ../script/variance.py
<<include_source>>
import sys
import os
import numpy
import terminal
import observer
import encoder
import node
import strategy
import splitter

inputSubject = terminal.TerminalSubject()
jsonLoadNode = node.JsonLoadNode()

varianceNode = node.StrategyNode(strategy.VarianceStrategy(initial = numpy.zeros(3)))
#splitter = splitter.SplitterBranchReplicator(headOfBranch = varianceNode)
#varianceNodeA = node.StrategyNode(strategy.VarianceStrategy(initial = numpy.zeros(3)))
#varianceNodeB = node.StrategyNode(strategy.VarianceStrategy(initial = numpy.zeros(3)))
#splitter.addNamedNode("MPL Accelerometer", varianceNodeA)
#splitter.addNamedNode("MPL Gyroscope", varianceNodeB)

jsonDumpNode = node.JsonDumpNode(jsonEncoder = encoder.NumpyEncoder)
fileObserver = terminal.FileObserver(f"{os.path.dirname(sys.argv[1])}/variance")
stdoutObserver = terminal.StdoutObserver()

inputSubject.addObserver(jsonLoadNode)
jsonLoadNode.addObserver(splitter.SplitterBranchReplicator(headOfBranch = varianceNode))
varianceNode.addObserver(jsonDumpNode)
#varianceNodeA.addObserver(jsonDumpNode)
#varianceNodeB.addObserver(jsonDumpNode)
jsonDumpNode.addObserver(fileObserver)
jsonDumpNode.addObserver(stdoutObserver)

inputSubject.startNotifying()
#+END_SRC
** COMMENT streamServer(Log & File)                              :deprecated:
#+BEGIN_SRC python :tangle ../script/run_streamServer.py
<<include_source>>
import asyncio
import stream
import datetime

class LogStreamSubscriber(stream.StreamSubscriber):
    def update(self, packet: str):
        print(packet)

class FileStreamSubscriber(stream.StreamSubscriber):
    def __init__(self, file: str):
        self.output = open(file, "w+")
        
    def update(self, packet: str):
        self.output.write(packet)

        
jsonStream = stream.StreamPublisher()
subscriber = {
    "log": LogStreamSubscriber(),
    "csv": FileStreamSubscriber(file = f"output/{datetime.datetime.now():%Y-%m-%d_%H:%M:%S}")
}

jsonStream.addSubscriber(subscriber["log"])
jsonStream.addSubscriber(subscriber["csv"])

try:
    asyncio.run(jsonStream.start(port = 11772))
except KeyboardInterrupt:
    sys.exit(0)
#+END_SRC
* Scrap
** Fusing with Nested Class Observers                                :T712_1:
#+BEGIN_SRC python
import quaternion

class OrientedVectorNode:
    def __init__(self, quaternionState, vectorState):
        self.subject = Subject() #TODO dependency injection
        self.quaternionObserver = self.QuaternionObserver()
        self.vectorObserver = self.VectorObserver()

    class QuaternionObserver(observer.Observer):
        def onUpdateFromSubject(self, package):
            self.quaternion = 

    class VectorObserver(observer.Observer):
        def onUpdateFromSubject(self, package):

        
#+END_SRC
** alias matrix variable
#+BEGIN_SRC python :eval no-export
import numpy
import enum

class State(enum.IntEnum):
    position = 0
    velocity = 1
    
state = numpy.array([1, 2])
velocity = state[1]
position = state[0]
print("pos:", state[State.position])
print("vel:", state[State.velocity])

state[1] = 4
print("pos:", state[State.position])
print("vel:", state[State.velocity])
#+END_SRC

#+RESULTS[4799896116125a2a317139001fa4e057c69bf34c]:
: pos: 1
: vel: 2
: pos: 1
: vel: 4
** plane tracking (kalman)
#+BEGIN_SRC python :eval no-export
import numpy as np
from numpy.linalg import inv

x_observations = np.array([4000, 4260, 4550, 4860, 5110])
v_observations = np.array([280, 282, 285, 286, 290])

z = np.c_[x_observations, v_observations]

# Initial Conditions
a = 2  # Acceleration
v = 280
t = 1  # Difference in time

# Process / Estimation Errors
error_est_x = 20
error_est_v = 5

# Observation Errors
error_obs_x = 25  # Uncertainty in the measurement
error_obs_v = 6

def prediction2d(x, v, t, a):
    A = np.array([[1, t],
                  [0, 1]])
    X = np.array([[x],
                  [v]])
    B = np.array([[0.5 * t ** 2],
                  [t]])
    X_prime = A.dot(X) + B.dot(a)
    return X_prime


def covariance2d(sigma1, sigma2):
    cov1_2 = sigma1 * sigma2
    cov2_1 = sigma2 * sigma1
    cov_matrix = np.array([[sigma1 ** 2, cov1_2],
                           [cov2_1, sigma2 ** 2]])
    return np.diag(np.diag(cov_matrix))


# Initial Estimation Covariance Matrix
P = covariance2d(error_est_x, error_est_v)
A = np.array([[1, t],
              [0, 1]])

# Initial State Matrix
X = np.array([[z[0][0]],
              [v]])
n = len(z[0])

for data in z[1:]:
    X = prediction2d(X[0][0], X[1][0], t, a)
    # To simplify the problem, professor
    # set off-diagonal terms to 0.
    P = np.diag(np.diag(A.dot(P).dot(A.T)))

    # Calculating the Kalman Gain
    H = np.identity(n)
    R = covariance2d(error_obs_x, error_obs_v)
    S = H.dot(P).dot(H.T) + R
    K = P.dot(H).dot(inv(S))

    # Reshape the new data into the measurement space.
    Y = H.dot(data).reshape(n, -1)

    # Update the State Matrix
    # Combination of the predicted state, measured values, covariance matrix and Kalman Gain
    X = X + K.dot(Y - H.dot(X))

    # Update Process Covariance Matrix
    P = (np.identity(len(K)) - K.dot(H)).dot(P)
    print("X:", X)
    print("P:", P)

print("Kalman Filter State Matrix:\n", X)
#+END_SRC

#+RESULTS[563ec8fbda592c500f687496fc37cc4a01753429]:
#+begin_example
X: [[4272.5]
 [ 282. ]]
P: [[252.97619048   0.        ]
 [  0.          14.75409836]]
X: [[4553.85054707]
 [ 284.29069767]]
P: [[187.4378327    0.        ]
 [  0.          10.46511628]]
X: [[4844.15764332]
 [ 286.22522523]]
P: [[150.30854278   0.        ]
 [  0.           8.10810811]]
X: [[5127.05898493]
 [ 288.55147059]]
P: [[126.38282157   0.        ]
 [  0.           6.61764706]]
Kalman Filter State Matrix:
 [[5127.05898493]
 [ 288.55147059]]
#+end_example
*
** numpy ndarray
 #+BEGIN_SRC python :eval no-export
import numpy

A = numpy.eye(6)
A[0:3, 3:6] = 2*numpy.eye(3)
#A = numpy.hstack((numpy.array([*numpy.eye(3), *numpy.eye(3)*2]), numpy.array([*numpy.zeros([3,3]), *numpy.eye(3)])))
print(A)
 #+END_SRC

 #+RESULTS[c2fea3356f7ba157f983b21c8e180a9c84903dec]:
 : [[1. 0. 0. 2. 0. 0.]
 :  [0. 1. 0. 0. 2. 0.]
 :  [0. 0. 1. 0. 0. 2.]
 :  [0. 0. 0. 1. 0. 0.]
 :  [0. 0. 0. 0. 1. 0.]
 :  [0. 0. 0. 0. 0. 1.]]

** transpose 3x9
#+BEGIN_SRC python :eval no-export
import numpy
H = numpy.hstack((numpy.zeros((3, 6)), numpy.eye(3)))
print(H)
print(H.T);

#+END_SRC

#+RESULTS[990d6266bc08304c4e82ce6ea39ec984e1ae8318]:
#+begin_example
[[0. 0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 1.]]
[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
#+end_example

** stdin read continuously
#+BEGIN_SRC python :tangle ../scrap/run_stdinLoop.py
import sys

for line in sys.stdin:
    print(line)
#+END_SRC

** subject/observer
#+BEGIN_SRC python :tangle ../scrap/test_stdinToStdout.py
<<include_source>>
import terminal
s = terminal.TerminalSubject()
o = terminal.StdoutObserver()
s.addObserver(o)
s.startNotifying()
#+END_SRC

#+BEGIN_SRC python :tangle ../scrap/test_stdinToFile.py
<<include_source>>
import terminal
import sys
s = terminal.TerminalSubject()
o = terminal.FileObserver(f"{sys.argv[0]}_output")
s.addObserver(o)
s.startNotifying()
#+END_SRC

** quaternion hamiltonian product
#+BEGIN_SRC python :eval no-export
import numpy
w1 = 1
w2 = 10
a = numpy.array([1, 2, 3])
b = numpy.array([2, 3, 4])
c = a*b
print(w1*w2-sum(c))

print(sum(a**2))

#+END_SRC

#+RESULTS[e19a4225ef6cb94074f406f493ba41c941abb820]:
: -10
: 14

** dict from list
#+BEGIN_SRC python :eval no-export
l = ["A", "B"]
d = {i: None for i in l}
print(d)

d = dict.fromkeys(l)
print(d)
#+END_SRC

#+RESULTS[420b00e48f63f7ae914bd04b0137135ba2400479]:
: {'A': None, 'B': None}
: {'A': None, 'B': None}

** clear dict values
#+BEGIN_SRC python :eval no-export
d = {"A": 1, "B": 2}
d = dict.fromkeys(d)
print(d)
#+END_SRC

#+RESULTS[d0c2a8905c7aa127e44889b5784960c338a222a2]:
: {'A': None, 'B': None}

** list from list (checking numpy array compatability)
#+BEGIN_SRC python :eval no-export
import numpy
vector = [1, 2, 3]
a = list(vector)
b = numpy.array(vector)
print(a)
print(b)
#+END_SRC

#+RESULTS[ad06cfbafab1c9bc9dac16ae92c212c99d84b011]:
: [1, 2, 3]
: [1 2 3]

** list from list and value
#+BEGIN_SRC python :eval no-export
a = [1, 2, 3]
b = 4.3
c = list([*a, b])
print(c)

import numpy
a = numpy.asarray(a)
c = numpy.array([*a, b])
print(c)
#+END_SRC

#+RESULTS[46e762ce8de75bca8876337649aa6ce502640afb]:
: [1, 2, 3, 4.3]
: [1.  2.  3.  4.3]

** cast list to float
#+BEGIN_SRC python :eval no-export
x = [5.4]
y = (1, 3, 5)
a = float(*x)
b = list(*y)
print(a)
print(y)
#+END_SRC

#+RESULTS[cf336f99ddc9779b7fd068e69854f37abeaa9540]:

* Other
#+name: include_source
#+BEGIN_SRC python
import sys
sys.path.append("../source")
#+END_SRC
